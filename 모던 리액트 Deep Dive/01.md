# 리액트의 등장 배경

리액트는 페이스북에서 복잡한 사용자 인터페이스를 구현하는 데 있어 기존의 자바스크립트 라이브러리와 프레임워크 (예: 바닐라 자바스크립트, 제이쿼리, 앵귤러 등)가 효율적이지 않다고 판단해 개발됐음.
페이스북은 자체 프레임워크인 `BoltJS`를 개발했으나, 내부적인 용도로만 사용되다가, 결국 `BoltJS` 에서 발전한 형태인 `리액트(React)`로 알려지게 됐습니다.
초기에는 `React.createClass` 방식을 사용했으나, 시간이 흐르면서 더 선언적이고 `함수형 프로그래밍`에 가까운 방식으로 발전했습니다.

### 단방향 데이터 바인딩

리액트에서는 `단방향 바인딩`은 데이터의 흐름이 한 방향으로만 이루어진다는 것을 의미.
컴포넌트의 `상태(state)` 가 변경되면, 해당 변경 사항이 `뷰(view)`에 반영되는 방식.
하지만 뷰에서 직접적으로 상태를 변경할 수 없으며, 상태는 변경하기 위해서는 상태 변경 함수를 사용해야 함.
-> `이러한 접근 방식은 데이터 흐름을 예측 가능하게 하고, 코드의 가독성을 향상시키고 버그 발생 가능성을 줄여줍니다`

```javascript
import React, { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      // `setCount` 함수를 호출하여 `count` 상태를 업데이트합니다.
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

`useState(0)` 은 `count`라는 상태를 0으로 초기화하고, 이 상태를 업데이트할 수 있는 함수 `setCount` 를 제공합니다.
사용자가 버튼을 클릭 할 떄 마다 `setCount` 함수가 호출되고, `count` 상태가 업데이트 되며, 리액트에 의해 화면에 반영이 됩니다.
이 과정에서 `데이터가 한 방향으로만 흐르는 단방향 데이터 바인딩 예시`

## 리액트 등장과 초기 회의적 의견

리액트는 초기에 JSX 구문을 도입 해, 자바스크립트 코드 내에 HTML 을 직접적으로 작성할 수 있도록 했습니다.
이 접근법은 `전통적 MVC 패턴과는 다른 방식`으로, 많은 개발자들에게 의아함을 주었고, 초기에는 호의적이지 않았습니다.
하지만, 리액트 팀은 `웹 애플리케이션을 효율적으로 관리하기 위한 새로운 패러다임`을 제시하고자 했고, 이는 시간에 지남에 따라, 점점 더 많은 개발자와 회사들에게 인정받게 됨.

리액트의 성장과 함께, 상태 관리 라이브러리 (예: Redux, Mobox), 라우팅 라이브러리 (예: React Router), 서버 사이드 렌더링 프레임워크(예: Next.js) 등 리액트를 보완하는 다양한 라이브러리 프레임워크가 등장하며, 리액트 생테계는 급속도로 확장되었습니다.

## 리액트 개발을 위해 꼭 알아야 할 자바스크립트 개념

### 1.1 자바스크립트의 동등 비교

리액트에서 함수형 컴포넌트를 작성하거나, 렌더링을 결정하는 데 있어 객체의 `얕은 비교`는 중요한 역할을 함.
리액트의 `가상 DOM 과 실제 DOM` 비교, 리액트 컴포넌트의 렌더링 결정 방법 등은 모두 자바스크립트의 동등 비교를 기반으로 합니다.

#### 원시 타입 (boolean, null, undefined, number, string, symbol, bigint)

값 자체가 메모리에 저장되며, 값으로 비교 됩니다.
타입은 불변 형태의 값으로 저장, 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장됩니다.

```javascript
let hello = "hello world";
let hi = hello;

console.log(hello === hi); // true
```

#### 객체 타입 (object/reference type)

객체 타입은 참조를 통해 비교됩니다. 즉, 같은 객체를 참조할 떄만 동등하다고 판단합니다.

```javascript
let hello = {
  greet: "hello, world",
};

let hi = {
  greet: "hello, world",
};

console.log(hello === hi); // false 그러나 동등 비교를 하면 false 나옴.
console.log(hello.greet === hi.greet); // true (내부 속성값과 비교를 하면 가능)
```

#### Object.is 에서 ==, === 차이

== 는 같음을 비교하기 전, `양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환.`
하지만 Object.is 에서는 이러한 작업을 하지 않아 === 와 동일하게 타입이 다르면 그냥 false

하지만 객체 비교에서는 별 차이가 없음.

```javascript
-0 === +0; // true
Object.is(-0, +0); // false

Number.NaN === NaN; // false
Object.is(Number.NaN, NaN); // true

NaN === 0 / 0; // false
Object.is(NaN, 0 / 0); // true

Object.is({}, {}); // false

const a = {
  hello: "hi",
};

const b = a;

Object.is(a, b); // true
a === b; // true
```

#### 리액트에서의 동등 비교

리액트는 `Object.is` 를 사용하여 동등 비교를 수행, 이는 상태 업데이트를 결정하거나, `React.memo` 와 같은 최적화 기능을 사용할 떄 중요.

### 리액트의 얕은 비교

리액트에서 `얕은 비교`는 주로 props 나 state 변화를 감지할 떄 사용됩니다.
이는 객체의 최상위 프로퍼티만을 비교 해, 객체 내부의 객체까지는 비교하지 않습니다. 이 방식은 성능상의 이유로 선택되었으며, 대부분 경우에서 충분한 정보를 제공합니다.

예를 들어, 컴포넌트의 props 가 변경되었는지 확인하기 위해 얕은 비교를 사용할 수 있습니다.

```javascript
function areEqual(prevProps, nextProps) {
  // 얕은 비교를 통해 props의 변경을 감지
  return prevProps.value === nextProps.value;
}

React.memo(MyComponent, areEqual);
```

#### 재귀적 비교의 문제점

객체 안에 중첩된 객체를 `완벽하게 비교하기 위해 재귀적 비교`를 수행할 경우, `성능 저하의 우려`가 있습니다. 객체의 깊이가 얼마나 될지 예측할 수 없고, 매 렌더링마다 깊은 비교를 수행하는 것은 리소스를 많이 소모할 수 있습니다. 따라서 리액트는 효율성과 실용성을 고려하여 얕은 비교를 기본 방식으로 사용합니다.

이러한 자바스크립트의 동등 비교 원리와 리액트에서의 적용 방식을 이해하는 것은 리액트 개발에 있어 중요한 요소입니다. 이를 통해 효율적인 컴포넌트 업데이트와 성능 최적화 전략을 구현할 수 있습니다.

## 함수

함수의 다양한 형태와 함수의 차이점이 무엇인지 알아보자.
Component 에서는 props 을 단일 props 으로 전달 하거나, {...props} 형태로 모든 props 을 전개 연산자로 받는 다는 차이가 있음.

### 함수 표현식

함수 표현식에 대해 알아보기 전 `일급 객체` 라는 개념을 알고 있어야 합니다.
프로그래밍 세계에서는 일급 객체란 `다른 객체들에 일반적 적용 가능한 연산을 모두 지원`하는 객체를 의미합니다.

자바스크립트에서 함수는 일급 객체입니다.
-> 함수는 다른 함수의 매개변수가 될 수 있고, 반환값이 될 수 있고, 앞에서 본 것처럼 할당도 가능하므로 일급 객체가 되기 위한 조건을 모두 갖추고 있습니다.

그리고 함수가 일급 객체라고 했으니, 함수를 변수에 할당하는 것도 가능합니다.

```javascript
const sum = function (a, b) {
  return a + b;
};
sum(10, 24); // 34
```

함수 표현식에서는 할당하려는 함수의 이름을 생략하는 것이 일반적.
-> 함수를 변수에 할당 할떄, function add(a,b) 이런식으로는 실제 프로덕션 코드에서는 절대로 사용해서는 안됩니다. `함수 표현식에서 함수에 이름을 주는 것은 함수 호출에 도움이 전혀 안 되는, 코드를 읽는 데 방해가 될 수 있습니다.`

### 함수 표현식과 선언 식의 차이

-> 이 두 가지 방식의 가장 큰 차이는 호이스팅(hoisting) 입니다.
함수의 호이스팅이라 함은, 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트 특징을 의미합니다.

```javascript
hello(); // hello

function hello() {
  console.log("hello");
}

hello(); // hello
```

함수가 중간에 있는데, 맨 앞에 호출한 hello() 어떠한 에러도 없이, 잘 호출되고 있음.
함수의 호이스팅은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미.
-> 이러한 함수의 호이스팅이라는 특징 덕분에 `함수 선언문이 미리 메모리에 등록`됐고, `코드의 순서에 상관없이 정상적으로 함수를 호출`할 수 있게 된 것 입니다.

반면 함수 표현식은 함수를 변수에 할당, 변수도 마찬가지 호이스팅이 발생, 그러나 함수의 호이스팅과는 다르게, 호이스팅되는 시점에서 let 경우에는 undefined 초기화가 되는 차이가 있습니다.

```javascript
console.log(typeof hello === "undefined"); // true
hello(); // Uncaught TypeError: hello is not a function

let hello = function () {
  console.log("hello");
};
hello();
```

앞선 함수 선언문과는 다르게, undefined 으로 되어 있음.
함수와 다르게 변수는, 런타임 이전에 undefined 로 초기화되고, 할당문이 실행되는 시점, 즉 런타임 시점에 함수가 할당되어 작동한다는 것을 알 수 있음.

화살표 함수

```javascript
const add = (a, b) => {
  return a + b;
};
const add = (a, b) => a + b; // constructor 사용 x, arguments 존재 x
```

화살표 함수와, 일반 함수의 큰 차이점은 `this 바인딩(this 는 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값)`
이 this 화살표 함수 이전까지 함수를 정의할 떄 결정되는 것이 아닌, 함수가 어떻게 호출되느냐에 따라 동적으로 결정됩니다.
-> 만약 함수가 일반 함수로서 호출된다면, 그 내부의 this 는 전역 객체를 가리키게 됩니다.
화살표 함수는 즉, 별도 작업을 추가하지 않고, this 에 접근할 수 있는 방법이 화살표 방법입니다.

### 다양한 함수 살펴보기

리액트에서 자주 쓰이는 함수 보기.

즉시 실행 함수.

- 함수를 정의하고, 그 순간 즉시 실행되는 함수를 의미, 단 한번만 호출되고, 다시 호출할 수 없음, 그래서 즉시 실행 함수에는 이름을 붙이지 않습니다.
  즉시 실행 함수의 장점도 있음, 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있다는 장점이 있습니다.
  일단 선언돼 있으면, 어디서 쓸지 모르는 일반 함수와는 다르게, 즉시 실행 함수는 그 선언만으로도 실행이 거기서 끝난다는 것을 각인시킬 수 있음.

```javascript
(function (a, b) {
  return a + b;
})(
  10,
  24
)(
  // 34
  (a, b) => {
    return a + b;
  }
)(10, 24);
```

고차 함수.

고차 함수는 - 일급 객체라는 특징을 활용 해 함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있습니다.

```javascript
const doubleArray = [1, 2, 3].map((item) => item * 2);
doubleArray; // [2, 4, 6]

// 함수를 반환하는 고차 함수의 예
const add = function (a) {
  // a가 존재하는 클로저를 생성
  return function (b) {
    // b를 인수로 받아 두 합을 반환하는 또 다른 함수를 생성.
    return a + b;
  };
};
add(1)(3); // 4
```

함수 컴포넌트 인수로 받아, 새로운 함수 컴포넌를 반환함. React 의 HOC 패턴의 컴포넌트라고 생각하면 됨.
-> 고차 함수 컴포넌트를 만들면 컴포넌트에 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있어, 효율적으로 리팩토링 가능합니다.

### 함수를 만들 떄, 주의해야 할 사항.

자바스크립트 코드를 작성할 떄, 관찰 해 보면, 변수를 자주 선언하는 것처럼, 함수를 자주 만들게 됨, 이런 습관적으로 함수를 만들다 보면, 함수 생성과 사용에 있어 중요한 부분을 놓칠 수 있음.

#### 함수의 부수 효과를 최대한 억제해라.

함수 부수 효과 (side-effect) 는 함수 내의 작동으로 인해 함수가 아닌, 함수 외부에 영향을 끼치는 것을 의미.
-> 부수 효과가 없는 함수를 순수 함수라고 의미. 부수 효과가 존재하는 함수를 비 순수 함수라고 합니다.
즉, 순수 함수는 부수 효과가 없고, 언제 어디서든 어떠한 상황에서든 동일 인수를 받으면 동일 결과를 반환해야 합니다, 그리고 작동 와중에 외부에 어떠한 영향도 미쳐서는 안됩니다.

```javascript
function PureComponent(props) {
  const { a, b } = props;
  return <div>{a + b}</div>;
}
```

-> 이 함수는 순수한 함수 컴포넌트라고 할 수 있음. 외부에 어떠한 영향 x, 언제 어디서든 동일 인수를 받아, 동일 결과를 반환하기 떄문 순수한 함수 컴포넌트라 볼 수 있음.
순수한 함수는 언제 실행되든 함수 결과가 동일하므로, 예측 가능하며, 안정적이라는 장점이 있습니다.

그렇다면 항상 순수 함수를 작성해야 할까?
웹 애플리케이션을 만들면서, 부수 효과는 피할 수 없는 요소.
컴포넌트 내부에서 API 를 호출하면 부수 효과가 됩니다.
-> 외부에 어떠한 영향 (HTTP request)을 끼쳤으므로 부수 효과., console.log 도 마찬가지 등.

부수 효과를 만드는 것은 애플리케이션을 만들면서 피할 수 없는 요소지만, 이런 부수 효과를 최대한 억제할 수 있는 방향으로 함수를 설계해야 합니다.
리액트 관점에서는 부수 효과를 처리하는 훅인 useEffect 의 작동을 최소화하는 것이 일환이라고 할 수 있음.
-> useEffect 사용은 피할 수 없지만, 최소한으로 줄임으로, 함수의 역할을 좁히고, 버그를 줄이며, 컴포넌트 안정성을 높일 수 있음.

#### 가능한 함수를 작게 만들자.

함수당 코드의 길이가 길어질수록 코드 냄새가 확률이 커지고, 내부에서 무슨 일이 일어나는지 추적하기 어려워집니다.
이 규칙에서 기본값으로 50줄 이상이 넘어가면 과도하게 커진 함수로 분류하고 경고 메시지를 출력 해 줍니다.
그리고 중첩된 것들이 얼마나 있고, 콜백은 얼마나 많은지도 이 규칙에서 확인이 가능합니다.
-> 가능한 함수 크기를 작게 하는 게 좋음.

#### 누구나 이해할 수 있는 이름으로 붙여라

함수명이나, 변수명을 만들 떄 다른 사람들이 알 수 없는 이름을 붙이는 건, 초기 몇 줄 안되는 코드는 이해하기 쉽지만,
점차 코드가 커지고 비즈니스 로직이 들어가면 코드가 많아질 수록, 더욱 어려움에 빠지게 됩니다.
